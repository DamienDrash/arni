# 2026-02-20

## Sicherheits-P0 Umsetzung (Fortsetzung)
- Post-filter-branch Cleanup gestartet im Parent-Repo `/root/.openclaw/workspace`.
- `refs/original` erfolgreich entfernt.
- `git reflog expire --expire=now --all` gestartet.
- `git gc --prune=now --aggressive` läuft aktuell noch (PID 1398183, pack-objects PID 1398187).
- Gateway-Livecheck: `GET http://127.0.0.1:8000/health` => `status=ok`.

## Wichtiger Kontext
- Das aktive `ariia`-Worktree ist aktuell sauber (keine unstaged/staged Änderungen im Repo selbst).
- Offene untracked Verzeichnisse im Parent-Repo: `getimpulse/`, `myclean-pipeline/`, `onepiece_tube_mangas/`.
- Stash-Referenzen im Parent-Repo existieren noch (`stash@{0..2}`), wurden durch filter-branch bereits rewrited.

## Next Steps
1. Warten bis laufendes `git gc` abgeschlossen ist.
2. Danach `git count-objects -vH` prüfen (Ziel: deutlich reduzierte loose objects).
3. Optional: alte Stashes droppen, wenn keine Wiederherstellung mehr nötig ist.

## Rebuild (P0 Security) – umgesetzt
- `config/settings.py` erweitert: `cors_allowed_origins`, `telegram_webhook_secret`, Auth-Flags, `bridge_auth_dir` default `/app/data/whatsapp/auth_info_baileys`.
- `app/gateway/main.py` gehärtet:
  - Startup guards (nur in Production) gegen Weak-Secrets/Legacy-Flags.
  - Bootstrap: `data/knowledge/members` wird beim Startup erstellt.
  - CORS auf konfigurierbare Origin-Liste + volle Methodenliste.
  - WhatsApp Webhook: optional Signatur-Validierung (strict in prod, ansonsten strict wenn Signature-Header geliefert).
  - Telegram Webhook: Secret-Validierung (strict in prod, ansonsten strict wenn Secret-Header geliefert).
- `app/integrations/whatsapp.py`: echte `hmac.compare_digest`-Prüfung, kein hardcoded `True` mehr.
- `app/gateway/admin.py`:
  - Secret-Redaction via `__REDACTED__` in `/admin/settings`.
  - Write-only Verhalten: `PUT /admin/settings/{key}` mit `__REDACTED__` behält bestehenden Secret-Wert.
  - Neue Endpunkte: `GET/PUT /admin/integrations/config` (Telegram/WhatsApp/Magicline), mit Redaction.
- `scripts/telegram_polling_worker.py`: sendet `x-telegram-webhook-secret`, falls gesetzt.
- `docker-compose.yml`:
  - zusätzliche Env-Passthroughs (Auth/CORS/Telegram-Secret/Meta-Secret/Bridge dir)
  - `forwarded-allow-ips` via Env statt `*`
  - knowledge bind mount `./data/knowledge:/app/data/knowledge` für core + telegram
  - Redis/Qdrant Host-Port-Publishing entfernt.
- `.gitignore`: WhatsApp Auth-Ordner + `node_modules` ignoriert.
- Neues Script: `scripts/security/rotate_p0_secrets.py`.
- Neue Tests: `tests/test_security_hardening.py`.
- Bestehende Tests für Webhook-Signaturen angepasst (`tests/test_gateway.py`, `tests/test_gateway_extended.py`).

## Verifikation
- `python -m py_compile` auf geänderten Python-Dateien: erfolgreich.
- `pytest -q tests/test_security_hardening.py`: 3 passed.
- Runtime smoke:
  - `GET /health` -> ok.
  - `GET /admin/integrations/config` erreichbar (via container-local curl).
  - `PUT /admin/settings/telegram_bot_token` gibt redacted Antwort zurück.
  - Telegram webhook ohne Header: 200 ignored (dev mode), mit falschem Header: 403.

## Hinweis
- Ein kompletter Suite-Lauf hängt in diesem Repo weiterhin bei einigen alten Gateway-Tests/Integrationsläufen (historisches Verhalten). Relevante P0-Security-Tests laufen grün.

## Restore-Fortschritt (Wiederaufbau nach Löschvorfall)
- Persistenter Restore-Plan stark erweitert: `docs/recovery/RESTORE_MASTER_PLAN_2026-02-20.md`.
- Wiederhergestellte Kernmodule bestätigt:
  - Auth/RBAC (`app/core/auth.py`, `app/gateway/auth.py`)
  - Governance-UI (`/login`, `/register`, `/users`, `/audit`)
  - Prompt/Member-Memory-Management (`/system-prompt`, `/member-memory`)
  - Daily Member Memory Scheduler (`app/memory/member_memory_analyzer.py`)
- Kritischer Runtime-Bug behoben:
  - `/auth/audit` lieferte 500 wegen Legacy-SQLite-Schema (`audit_logs` ohne neue Spalten).
  - Migration in `app/core/db.py` erweitert um fehlende Audit-Spalten inkl. `tenant_id`.
  - Laufende DB im Container korrigiert; Endpoint erneut getestet: `GET /auth/audit?limit=5 -> 200 []`.
- Smoke-Status (live gegen Gateway):
  - `POST /auth/register` 200
  - `POST /auth/login` 200
  - `GET /auth/me` 200
  - `GET /auth/users` 200
  - `GET /auth/audit` 200
  - `GET /admin/prompts/ops-system` 200
  - `GET /admin/member-memory` 200

## Offene Premium-Punkte nach Restore
1. Vollständige Multi-Tenant-Datenisolation über alle Domänenendpunkte prüfen/erzwingen.
2. SQLite -> Postgres als Standard für echte High-End Multi-Tenant SaaS umstellen.
3. RBAC-Ende-zu-Ende-Testmatrix in CI verbreitern.

## Premium Hardening + UX (Fortsetzung)
- `admin` RBAC auf globale Endpunkte verschärft: nur `system_admin`.
- Postgres-first vorbereitet (`DATABASE_URL`, `psycopg`, `postgres` compose service, SQLite fallback).
- Frontend basePath/Auth-Fixes abgeschlossen (`/ariia/api/auth/*` sicher).
- Sidebar/IA aufgeräumt und visuell premium ausgerichtet.
- Verifikation live:
  - system admin login über frontend proxy: 200
  - tenant_admin auf `/admin/settings`: 403
  - system_admin auf `/admin/settings`: 200

## Restore-Fortsetzung: Tenant UX + Postgres
- Sidebar ist jetzt rollenbasiert gefiltert (Tenant-Admins sehen system-only Bereiche nicht).
- Zusätzlicher RBAC-Test: Tenant-Admin -> 403 auf `/admin/knowledge` und `/admin/stats`.
- Neues Migrationsscript: `scripts/data/migrate_sqlite_to_postgres.py` (dry-run + reset-target).
- Migration ausgeführt und erfolgreich nach Postgres übernommen:
  - users 5, tenants 5, studio_members 182, settings 22, chat_sessions 1, chat_messages 33, audit_logs 1.
- `.env` auf Postgres umgestellt (`DATABASE_URL=postgresql+psycopg://...@postgres:5432/ariia`).
- `ariia-core`/`ariia-telegram` neu gestartet und live geprüft (auth + admin endpoints ok).

## Restore Fortsetzung (Knowledge + Telegram)
- Editor-Lesbarkeit für Knowledge/Member-Memory/System-Prompt final gefixt (`TiptapEditor` + `.ariia-editor` CSS in `globals.css`).
- `ariia-telegram` Health dauerhaft korrigiert: eigener Worker-Healthcheck in `docker-compose.yml` (Python `/proc/1/cmdline`), Status jetzt `healthy`.
- Verifiziert:
  - `frontend` Typecheck grün
  - `frontend` ESLint für geänderten Editor grün
  - Auth/Security-Tests: `4 passed`

## R7 Tenant Isolation – Fortschritt
- `auth`-Ebene gehärtet: reservierte Tenant-Slugs blockiert, User-Creation-Regeln strikter (system_admin nur im system-Tenant, tenant_id Pflicht für system_admin bei tenant-user/admin-Erstellung).
- Postgres-Bug `/auth/audit` behoben (vorher `ProgrammingError`, jetzt 200).
- Tests erweitert und grün: `6 passed` (`test_auth_restore` + `test_security_hardening`).
- Nächster Schritt: tenant_id in Chat-Datenmodell + Tenant-Scope Enforcement in Chat-/Domain-Layern.

## R7 Datenebene
- Chat-Persistenz tenant-fähig gemacht (`tenant_id` in `chat_sessions` und `chat_messages` + runtime Migration für Postgres/SQLite).
- `PersistenceService` jetzt tenant-aware mit System-Tenant-Fallback und Legacy-Backcompat.
- Live geprüft: Spalten vorhanden, `/auth/audit` und `/health` jeweils 200.
- Offene strukturelle Restlücke: `chat_sessions.user_id` ist noch global unique; nächster Schritt ist Composite-Key `(tenant_id, user_id)`.

## R7 Composite-Key Vorbereitung
- Globaler unique-Constraint auf `chat_sessions.user_id` in Postgres aufgehoben und durch Composite-Unique `(tenant_id, user_id)` ersetzt.
- Zusätzlich non-unique Suchindex auf `user_id` beibehalten.
- Ergebnis: technische Grundlage für gleiche externe User-IDs über mehrere Tenants ist gelegt.

## R7 Read-Path Tenant Propagation
- Tenant-ID nun in Inbound/Outbound Schemas.
- Gateway + Persistence-Helfer + Swarm-History-Lesezugriffe tenant-aware gemacht.
- Admin Chat-Read-/Reset-Pfade übergeben jetzt tenant_id in Persistence.
- Verifiziert nach Core-Restart: `/health` 200, `/auth/audit` 200, Tests weiterhin `6 passed`.
- Offener großer Punkt: echte tenant-native Auflösung pro Kanal + Tenantisierung von StudioMember/Knowledge/MemberMemory Daten.

## R9 Seed (Tests)
- Tenant-Scope Regressiontests für Persistence ergänzt (`test_persistence_tenant_scope.py`).
- Bestätigt: gleiche `user_id` in verschiedenen Tenants liefert tenant-getrennte History/Sessions.
- Teststatus erweitert: insgesamt `8 passed` im kombinierten Lauf.

## Domain Tenantization (StudioMember)
- `StudioMember` tenantisiert: neue `tenant_id`, composite-unique `(tenant_id, customer_id)` in Postgres, Legacy-Daten auf system-Tenant backfilled.
- `run_migrations()` jetzt explizit im Gateway-Lifespan, damit Startup-Migrationen sicher laufen.
- Admin Member APIs + Magicline Sync/Enrichment + Phone-Matching tenant-scoped gemacht.
- Live bestätigt: `/admin/members/stats` 200, `studio_members tenant_null=0`, Tests weiterhin 8 passed.

## Restore Fortsetzung (2026-02-20, später)
- Tenant-/Knowledge-Fortsetzung umgesetzt und live ausgerollt.
- `app/memory/member_memory_analyzer.py` gehärtet:
  - System-Tenant schreibt Member-Memory wieder in Legacy-Pfad `data/knowledge/members`.
  - Tenant-Pfad mit Permission-Fallback auf Legacy.
  - Persistente Extraktionsanweisung eingeführt (`data/knowledge/member-memory-instructions.md`) inkl. Default-Template.
  - Analyzer-Inhalt erweitert um Abschnitt `Analytische Zusammenfassung` + eingebettete Anweisung + Chat-Kontext.
- Neue Admin-API für Member-Memory-Extraktionsanweisung:
  - `GET /admin/prompts/member-memory-instructions`
  - `POST /admin/prompts/member-memory-instructions`
- Frontend erweitert:
  - `system-prompt` Seite kann jetzt zwischen `Ops Prompt` und `Member Memory Prompt` umschalten/editieren.
  - `member-memory` Seite auf Knowledge-ähnliche UI gehoben (inkl. Draft-Datei anlegen via `+`).
  - Sidebar IA angepasst: `Magicline Sync` unter `System` statt `Customers`.
- Betriebsfix für 500 bei Prompt-Speicherung:
  - Root cause: Schreibrechte auf `data/knowledge` für Container-User fehlten.
  - Fix: Hostrechte auf `data/knowledge` auf UID/GID `1000:1000` gesetzt.
- Verifikation:
  - Tests: `pytest -q tests/test_auth_restore.py tests/test_persistence_tenant_scope.py tests/test_security_hardening.py` => `8 passed`.
  - API smoke:
    - `GET /admin/prompts/member-memory-instructions` => 200
    - `POST /admin/prompts/member-memory-instructions` => 200
    - Datei wird persistiert in `data/knowledge/member-memory-instructions.md`.
  - Frontend neu gestartet/build erfolgreich, Seiten erreichbar (`/ariia`, `/ariia/knowledge`, `/ariia/member-memory`, `/ariia/system-prompt` => 200).

## Offene nächste Schritte (empfohlen)
1. Analyzer von heuristischer Zusammenfassung auf echte LLM-Extraktion mit JSON-Schema-Ausgabe umstellen.
2. Tenant-spezifische Prompt-/Memory-Bearbeitung auch für `tenant_admin` (statt nur `system_admin`) designen/entscheiden.
3. E2E-Testfall ergänzen: Prompt im UI ändern -> täglicher Analyzer nutzt geänderte Anweisung nachweisbar.

## Fortsetzung (LLM Analyzer Upgrade)
- `app/memory/member_memory_analyzer.py` von heuristischer-only Logik auf LLM-gestützte Extraktion erweitert.
- Neue Hilfsfunktionen:
  - `_extract_first_json_object()` für robustes JSON-Parsen aus LLM-Antworten.
  - `_format_llm_profile()` für standardisierte Markdown-Zusammenfassung.
  - `_extract_profile_with_llm_async()` mit OpenAI-Call (modellgesteuert), strict JSON-Output und Fallback.
- Laufzeitverhalten:
  - LLM-Extraktion nur aktiv, wenn `OPENAI_API_KEY` gesetzt und Setting `member_memory_llm_enabled=true`.
  - Bei Fehler/invalidem JSON automatisch heuristischer Fallback.
- Neue Settings Defaults in `app/gateway/persistence.py`:
  - `member_memory_llm_enabled=true`
  - `member_memory_llm_model=gpt-4o-mini`
- Neue Tests: `tests/test_member_memory_analyzer.py`.
- Verifikation:
  - Tests gesamt: `11 passed` (inkl. neuer Analyzer-Tests).
  - Deployment `ariia-core` durchgeführt.
  - Live geprüft: `/admin/settings` enthält `member_memory_llm_enabled` und `member_memory_llm_model`.
- Frontend UX-Update in `frontend/app/settings/page.tsx`:
  - `member_memory_llm_enabled` als Toggle.
  - Labels für beide neuen Settings ergänzt.

## Fortsetzung (E2E Analyze-Now Flow)
- Neuer Admin-Endpoint implementiert: `POST /admin/member-memory/analyze-now` in `app/gateway/admin.py`.
  - Triggert sofortige Analyse (`analyze_all_members` oder optional gezielt via `member_id`).
  - Persistiert `member_memory_last_run_at` und `member_memory_last_run_status`.
- Frontend `/member-memory` erweitert (`frontend/app/member-memory/page.tsx`):
  - Button `Analyse jetzt`.
  - Anzeige von letztem Run-Zeitpunkt + Status aus `/admin/settings`.
- Robustheitsfix im Analyzer (`app/memory/member_memory_analyzer.py`):
  - `_write_text_safe()` ergänzt (PermissionError-behandlung + inode-replace + fallback file path), damit veraltete Datei-Ownership den Run nicht mehr blockiert.
- Tests aktualisiert:
  - `tests/test_auth_restore.py`: RBAC für `analyze-now` (tenant_admin 403, system_admin 200).
- Verifikation live:
  - `POST /admin/member-memory/analyze-now` => 200, `status=ok`.
  - `member_memory_last_run_status` => `ok`.
  - Externe Seiten wieder erreichbar: `/ariia`, `/ariia/member-memory`, `/ariia/settings` => 200.

## Incident-Fix: Live Monitor + Telegram Technical Error
- Root causes identifiziert:
  1) `chat_messages` Inserts schlugen fehl wegen Postgres-Sequence-Drift (`chat_messages_id_seq` hinter `max(id)`) -> kein Live-Monitor-Update.
  2) Ops-Agent warf `NameError` wegen fehlender Funktion `_load_magicline_skill_prompt` -> Fallback-Antwort "Kurz ein technischer Fehler...".
- Fixes:
  - `app/core/db.py`: `run_migrations()` setzt in Postgres Sequences für `chat_sessions.id` und `chat_messages.id` per `setval(...)` auf `max(id)`.
  - `app/swarm/agents/ops.py`: `_load_magicline_skill_prompt()` wieder ergänzt (caching + safe fallback).
- Verifikation:
  - DB geprüft: `chat_messages max(id)=33`, `chat_messages_id_seq last_value=33`.
  - Simulierter Telegram-Webhook (`user_id=7473721797`) -> `/webhook/telegram` 200.
  - Danach `/admin/chats` zeigt Session `7473721797` mit `member_id=6-1381`, `is_active=true`, aktueller `last_active`.
  - `/admin/chats/7473721797/history` liefert neue user+assistant Messages.
  - Extern `/ariia/live` 200.
- Status User-Verifizierung:
  - Telegram-Session `7473721797` hat `member_id=6-1381` -> User ist verifiziert.

## Verification Flow Upgrade (E-Mail statt Chat-Token)
- Neuer SMTP-Mailer ergänzt: `app/integrations/email.py`.
- Gateway-Verifizierungsflow in `app/gateway/main.py` umgestellt:
  - Kein Token-Hinweis mehr im Chat.
  - Unverifiziert: erst Telefonnummer teilen.
  - Bei Match + vorhandener E-Mail: Token wird erzeugt und per SMTP-Mail versendet.
  - Token bleibt 24h in Redis und wird im Chat eingegeben.
  - Token-Validierung jetzt mit User-Binding (`token_user_id` muss `message.user_id` matchen).
- `match_member_by_phone` liefert jetzt auch `email` zurück (`app/gateway/member_matching.py`).
- Integrations-API erweitert (`app/gateway/admin.py`): neuer SMTP-Block in `GET/PUT /admin/integrations/config`.
- Default-Settings erweitert (`app/gateway/persistence.py`): SMTP-Keys + `verification_email_subject`.
- App-Settings erweitert (`config/settings.py`): SMTP/Betreff-Fallbacks.
- Frontend `/settings` erweitert (`frontend/app/settings/page.tsx`):
  - Neue Integrationssektion für Telegram, WhatsApp, Magicline, SMTP.
  - Persistenz über `/admin/integrations/config`.
- Verifikation:
  - `python -m py_compile` auf geänderten Python-Dateien: ok.
  - `eslint` für `frontend/app/settings/page.tsx`: ok.
  - `tsc --noEmit` im Frontend: ok.
  - Backend-Tests: `.venv/bin/pytest -q tests/test_auth_restore.py tests/test_persistence_tenant_scope.py tests/test_security_hardening.py` => `8 passed`.

## Bugfix: Live Monitor + Eskalationen (2026-02-20, später)
- Problem 1: Eskalationen waren nicht zuverlässig triggerbar (abhängig vom Persona-Tool-Aufruf).
- Lösung Backend (`app/gateway/main.py`):
  - Deterministische Handoff-Erkennung via Keywords (`mitarbeiter`, `support`, `mensch`, etc.).
  - Bei Treffer wird `session:{user_id}:human_mode` gesetzt (24h), User-Nachricht + System-Antwort persistiert und AI-Antwort übersprungen.
  - Fallback-Redis-Write ergänzt, falls shared redis client temporär nicht verfügbar ist.
- Problem 2: Live Monitor wirkte nicht live (WS-Routing instabil / zu langsamer Fallback).
- Lösung Frontend (`frontend/app/live/page.tsx`):
  - Polling-Frequenz erhöht (Sessions 3s statt 10s, History 2s statt 4s).
  - WS-Kandidatenreihenfolge bereinigt (`/ws/control` priorisiert) + robustes JSON-Parsing im WS-Handler.
  - State-Lint-Fixes (kein synchrones `setState` in Effects).
- Verifikation:
  - Eskalations-Trigger getestet: Telegram-Nachricht "Ich will mit einem Mitarbeiter sprechen" -> `gateway.handoff.requested` Log + Eintrag in `/admin/handoffs`.
  - Ergebnis `/admin/handoffs`: user `7473721797` mit `session:7473721797:human_mode` vorhanden.

## Live Monitor UX Fixes (2026-02-20)
- `frontend/app/live/page.tsx`:
  - `/admin/chats?limit=200` statt default limit.
  - Auto-Select erster verfügbarer Session, wenn keine/ungültige Auswahl -> Chatpanel inkl. Eingabefeld bleibt sichtbar.
  - Token-Banner nur für unverifizierte Sessions (`member_id` fehlt).
  - Manual Token wird beim Session-Wechsel zurückgesetzt.
- `app/gateway/admin.py`:
  - `/admin/chats` zeigt/behält Tokens nur für unverifizierte Sessions.
  - Für verifizierte Sessions werden Legacy-`user_token` Einträge aus Redis aktiv entfernt und `active_token=null` geliefert.
  - Gleiches Verhalten für `/admin/handoffs`.
- `app/gateway/persistence.py`:
  - `get_recent_sessions(..., active_only=False)` erweitert; `/admin/chats` kann damit auch nicht strikt auf `is_active=true` limitiert werden.
- Verifikation:
  - `/admin/chats?limit=200` für User `7473721797` zeigt `member_id=6-1381`, `active_token=null`.
  - `redis GET user_token:7473721797` ist leer.
  - `/ariia/live` wieder `200` nach Frontend-Rebuild.

## Frontend Premium Hardening (später am 2026-02-20)
- Commit `e36d27dc`:
  - WhatsApp Outbound im Gateway von `/api/send` entkoppelt (direkt über WhatsApp-Client in `app/gateway/main.py`).
  - `/ariia/api/send` in `frontend/app/api/send/route.ts` auf optionalen, token-gated Legacy-Proxy umgestellt (`NEXT_ENABLE_LEGACY_SEND_PROXY`, `LEGACY_SEND_TOKEN`, `WHATSAPP_BRIDGE_SEND_URL`).
  - Neue wiederverwendbare `Modal`-Komponente (`frontend/components/ui/Modal.tsx`) mit Focus-Trap/Escape/Backrop-Close.
  - Overlays in `live`, `users`, `tenants`, `escalations` auf `Modal` migriert.
- Commit `bf29db73`:
  - `frontend/app/audit/page.tsx` auf Governance-UX erweitert: CSV-Export, Filter-Reset, Detail-Modal mit formatiertem Payload.
  - `frontend/app/global-error.tsx` in Incident-View überführt (Incident-ID/Digest + klare Recovery-Actions).
- Verifikation:
  - `npm run lint` grün.
  - `npm run build` grün (bekannte DaisyUI `@property` Warnung unverändert).

## Sprint Security P0 (Cookie Session + CSRF)
- Commit `64d5a455`: Frontend Auth/Proxy Security gehärtet.
- Cookie-only Session erzwungen:
  - `frontend/lib/api.ts` entfernt Authorization-Header-Injektion aus `sessionStorage`.
  - `frontend/lib/auth.ts` speichert nur noch User-Metadaten in `sessionStorage`; Token wird nur als HttpOnly-Cookie geführt.
- CSRF Double-Submit Schutz eingeführt:
  - `frontend/lib/server/proxy.ts`: `CSRF_COOKIE`, `validateCsrf()`, `setCsrfCookieHeaders()`.
  - `frontend/app/api/admin/[...path]/route.ts`: CSRF-Check für mutierende Methoden.
  - `frontend/app/internal/admin/[...path]/route.ts`: CSRF-Check für mutierende Methoden.
  - `frontend/app/proxy/admin/[...path]/route.ts`: CSRF-Check für mutierende Methoden.
  - `frontend/app/api/auth/[...path]/route.ts`: CSRF-Check für mutierende Methoden außer `login/register/logout`; CSRF-Cookie bei erfolgreichem Login/Register gesetzt.
- Validierung:
  - `npm run lint` => ok
  - `npm run build` => ok (nur bekannte DaisyUI `@property` Warnung)

## Live Monitor Realtime-First
- Commit `2ffeba67`: `frontend/app/live/page.tsx` auf Realtime-first umgestellt.
- Änderungen:
  - Polling nicht mehr dauerhaft aktiv; nur Fallback wenn WS nicht verbunden ist.
  - WS-Reconnect mit Exponential Backoff (bis 15s), inkl. Candidate-Fallback URLs.
  - Event-Refresh debounced (`scheduleRefresh`) für Sessions+History statt aggressiver Mehrfach-Requests.
  - Statusindikator präzisiert: `Realtime aktiv`, `Verbinde…`, `Fallback Polling`.
- Ergebnis: geringere Dauerlast, konsistenterer Live-Feed und robustere Reconnects.
- Verifikation:
  - `npm run lint` => ok
  - `npm run build` => ok (bekannte DaisyUI `@property` Warnung bleibt)

## Users/Tenants Enterprise Upgrade
- Commit `a6f28cd0`: Governance-Funktionalität in Frontend-Adminseiten ausgebaut.
- `frontend/app/users/page.tsx`:
  - Multi-Select + Bulk Activate/Deactivate mit Confirm-Modal.
  - User-Detail-Modal mit Governance-Kennzahlen + letzter Audit-Timeline (target `user`).
  - Separate Actions `Details` + `Bearbeiten` pro Zeile.
- `frontend/app/tenants/page.tsx`:
  - Multi-Select + Bulk Activate/Deactivate (system_admin).
  - Tenant-Detail-Modal mit Tenant-Metriken, User-Verteilung und Audit-Timeline (target `tenant`).
  - Separate Actions `Details` + `Bearbeiten` pro Zeile.
- Verifikation:
  - `npm run lint` => ok
  - `npm run build` => ok (bekannte DaisyUI `@property` Warnung bleibt)

## Settings Operator Experience (Integrations)
- Commit `fbe32974`:
  - Backend: neuer Endpoint `POST /admin/integrations/test/{provider}` für `telegram|whatsapp|magicline|smtp`.
  - Testläufe persistieren in Settings:
    - `integration_<provider>_last_test_at`
    - `integration_<provider>_last_status`
    - `integration_<provider>_last_detail`
  - Frontend `frontend/app/settings/integrations/page.tsx` auf Operator-UX gehoben:
    - Pro Connector `Test Connection` Button
    - Persistenter Last-Test-Status + Detailanzeige
    - Health-Summary über alle Connectoren
- Verifikation:
  - `python -m py_compile app/gateway/admin.py` => ok
  - `npm run lint` => ok
  - `npm run build` => ok (bekannte DaisyUI `@property` Warnung bleibt)

## Deployment + Next Step (Automation Ops)
- Deploy durchgeführt via `docker compose up -d --force-recreate ariia-core ariia-telegram ariia-frontend`.
- Post-deploy verifiziert:
  - `GET http://127.0.0.1:8000/health` => `status=ok`
  - `https://services.frigew.ski/ariia/settings/integrations` => 200
  - `https://services.frigew.ski/ariia/settings/automation` => 200
- Neuer nächster Schritt umgesetzt (Commit `91f95280`):
  - Backend: `GET /admin/member-memory/status`
  - Frontend: `settings/automation` mit Status-Karten, Fehlerdetails (`error:*`), Cron-Presets, Auto-Refresh.

## Settings General Governance Upgrade
- Commit `03ee43f3`:
  - Backend `app/gateway/admin.py`: Audit-Logging für `setting.update` ergänzt (inkl. `reason`, old/new values redacted bei sensiblen Keys).
  - Frontend `frontend/app/settings/general/page.tsx` komplett auf Governance-UX umgestellt:
    - Gruppierung (Security/Runtime/Data/Compliance)
    - Risk/Impact Badges
    - Soft-Validation (Cron/URL/Port)
    - Confirm-Modal für Änderungen + Pflicht-Reason bei kritischen Settings
    - Integrierte Timeline der letzten Settings-Audit-Events
- Deploy & Verify:
  - `docker compose up -d --force-recreate ariia-core ariia-frontend`
  - `GET /health` => ok
  - `https://services.frigew.ski/ariia/settings/general` => 200

## Knowledge + Member Memory Premium Upgrade
- Commit `aeeef897`:
  - Backend:
    - `GET /admin/knowledge/status`
    - `POST /admin/knowledge/reindex`
    - Knowledge-Ingest (`app/knowledge/ingest.py`) liefert jetzt strukturierte Result-Statistiken (`status/files/chunks`).
    - Save/Reindex persistiert Last-Ingest-Metadaten in Settings (`knowledge_last_ingest_at/status/error`).
  - Frontend:
    - `frontend/app/knowledge/page.tsx` auf Dashboard-Muster gehoben (Statuskarten, Last-Ingest, Reindex-Action, bessere Zustände).
    - `frontend/app/member-memory/page.tsx` auf gleiches Muster gehoben (Statuskarten, Last-Run, Analyze-Action, Auto-Refresh).
- Verifikation:
  - `python -m py_compile app/gateway/admin.py app/knowledge/ingest.py` => ok
  - `npm run lint` => ok
  - `npm run build` => ok
- Deploy + Live-Checks:
  - `https://services.frigew.ski/ariia/knowledge` => 200
  - `https://services.frigew.ski/ariia/member-memory` => 200

## Auth Stability + Editor Autosave/Conflict
- Commit `2288d89a`:
  - Login/Session-Stabilität verbessert:
    - `frontend/components/NavShell.tsx` bootstrapped Auth via `/auth/me` when sessionStorage is empty, statt sofortigem Redirect.
    - `frontend/lib/auth.ts` ergänzt um `setStoredUser(...)` für cookie-basierte Session-Rehydration.
  - Knowledge/Member-Memory Editor gehärtet:
    - Backend `app/gateway/admin.py`: Dateien liefern jetzt `mtime`; Save akzeptiert `base_mtime` und gibt 409 bei Konflikt.
    - Frontend `frontend/app/knowledge/page.tsx` + `frontend/app/member-memory/page.tsx`:
      - Dirty-State + Autosave (debounced)
      - Konflikt-Handling mit `Reload` / `Overwrite`
- Verifikation:
  - `npm run lint` => ok
  - `npm run build` => ok
  - Deploy + Live-Checks:
    - `/ariia/login` => 200
    - `/ariia/knowledge` => 200
    - `/ariia/member-memory` => 200

## Incident Analyse: Direktes Logout nach Login
- Root Cause bestätigt:
  - `POST /ariia/api/auth/login` liefert zwar `access_token`, setzt aber aktuell keinen `Set-Cookie` Header.
  - Dadurch schlägt nach Navigation `GET /auth/me` ohne Authorization mit `401 Missing bearer token` fehl.
  - Frontend räumt bei 401 die Session und wirkt wie "sofort ausgeloggt".
- Technischer Fix (Commit `f277b9a4`):
  - `frontend/lib/auth.ts`: `ariia_access_token` wieder in `sessionStorage` als Fallback gespeichert.
  - `frontend/lib/api.ts`: Authorization-Header aus `sessionStorage` gesetzt, falls vorhanden.
  - `frontend/components/NavShell.tsx`: Auth-Bootstrap stabilisiert, Redirect erst nach geprüftem Zustand.
- Live-Checks:
  - `/ariia/login` => 200
  - `/ariia/api/auth/me` mit Bearer-Token => 200

## Incident Root Cause (Logout bei Klick auf Wissensbasis)
- Root Cause identifiziert:
  - Routing-Kollision in FastAPI: `/admin/knowledge/{filename}` hat `/admin/knowledge/status` geschluckt.
  - Folge: `knowledge/status` lieferte 404 statt Status-JSON; Frontend-Fallback-Kette erzeugte in bestimmten Fällen 401-Kaskaden und Session-Clear.
- Fix (Commit `c53cf240`):
  - konfliktfreie Dateirouten eingeführt:
    - `GET/POST /admin/knowledge/file/{filename}`
    - `GET/POST /admin/member-memory/file/{filename}`
  - Frontend-Endpunkte in `/knowledge` und `/member-memory` entsprechend angepasst.
- Verifikation:
  - `GET /ariia/api/admin/knowledge/status` mit Bearer => 200
  - Live-Seiten: `/ariia/knowledge`, `/ariia/member-memory`, `/ariia/login` => jeweils 200

## Governance Hardening (Knowledge/Prompt/Member-Memory)
- Backend `app/gateway/admin.py` erweitert:
  - `SaveFileRequest` hat jetzt `reason`.
  - Pflichtbegründung für Änderungen (`min 8 chars`) auf:
    - `POST /admin/knowledge/file/{filename}`
    - `POST /admin/member-memory/file/{filename}`
    - `POST /admin/prompts/ops-system`
    - `POST /admin/prompts/member-memory-instructions`
  - Prompt-Endpunkte liefern jetzt `mtime`; Prompt-Save unterstützt `base_mtime` + 409-Konfliktschutz.
  - Audit-Events ergänzt:
    - `knowledge.update`
    - `member_memory.update`
    - `prompt.ops.update`
    - `prompt.member_memory.update`
- Frontend angepasst:
  - `frontend/app/knowledge/page.tsx`
  - `frontend/app/member-memory/page.tsx`
  - `frontend/app/system-prompt/page.tsx`
  - Alle drei Bereiche haben nun sichtbares Feld für Änderungsgrund (min. 8 Zeichen), senden `reason` mit und behandeln Prompt-Konflikte.
- Tests ergänzt:
  - Neu: `tests/test_admin_governance_reasons.py`.
  - Validiert 422 ohne Reason und 200 mit Reason für Knowledge/Member-Memory/Prompts.
- Verifikation:
  - `python -m py_compile app/gateway/admin.py` ✅
  - `.venv/bin/pytest -q tests/test_admin_governance_reasons.py tests/test_auth_restore.py` => `6 passed` ✅
  - `frontend`: `npm run lint` ✅, `npm run build` ✅

## Follow-up Umsetzung (User Request: 1,3,4,5)
- 1) Auth Cookie-only finalisiert:
  - `frontend/lib/api.ts`: Authorization-Header-Injektion aus `sessionStorage` entfernt.
  - `frontend/components/NavShell.tsx`: Bootstrap prüft nur noch `/auth/me` + gespeicherten User; kein Token-Gate mehr.
  - `frontend/lib/auth.ts`: `storeSession` speichert keine Tokens mehr, nur User-Metadaten.
  - Live-Smoke: `POST /ariia/api/auth/login` setzt `ariia_access_token` + `ariia_csrf_token`; `GET /ariia/api/auth/me` nur via Cookie => 200.
- 3) Live Monitor Realtime-Härtung:
  - `frontend/app/live/page.tsx`: WS-Heartbeat/Watchdog ergänzt.
  - Bei >20s ohne WS-Events wird Status `stale` gesetzt und Reconnect erzwungen.
  - UI-Status erweitert (`Realtime aktiv`, `Verbinde…`, `Reconnect…`, `Fallback Polling`).
- 4) Audit Log Governance-UX:
  - `frontend/app/audit/page.tsx`: zusätzliche Facetten (Actor, Target-Type), Category-Chips mit Counts.
  - Detail-Verbesserung: Reason/Payload-Summary in Tabelle + strukturierte Diff-Ansicht (old/new) im Modal.
- 5) Ops-Hygiene:
  - Neues Script `scripts/ops/cleanup_local_dev_processes.sh` (dry-run + `--apply`).
  - Hängende alte lokale `pytest`-Prozesse aus dem Workspace beendet.
  - Aktueller Dry-Run: keine stale lokalen Dev-Prozesse mehr.
- Verifikation:
  - `frontend`: `npm run lint` und `npm run build` grün.
  - Deploy: `docker compose up -d --force-recreate ariia-core ariia-frontend`.
  - Live: `/ariia/live`, `/ariia/audit`, `/ariia/login` jeweils 200.

## Tenant-Scoped Config Isolation (Settings) umgesetzt
- `settings` auf tenant-scope umgestellt: `Setting`-Model nutzt jetzt Composite-Key (`tenant_id`, `key`).
- Runtime-Migration erweitert (`app/core/db.py`):
  - `settings.tenant_id` wird angelegt (falls fehlend).
  - Legacy-Settings mit `tenant_id IS NULL` werden auf System-Tenant backfilled.
  - Postgres: PK von `key` auf `(tenant_id, key)` umgestellt + Indizes.
- `PersistenceService` settings API tenant-aware:
  - `get_settings(tenant_id=...)`
  - `get_setting(..., tenant_id=..., fallback_to_system=True)`
  - `upsert_setting(..., tenant_id=...)`
  - explizite globale System-Keys (`billing_*`) bleiben systemweit.
- SQLite-Kompatibilität ergänzt (Legacy unique `settings.key`):
  - tenant-namespaced storage keys (`tenant:<id>:<key>`) für tenant-spezifische Overrides.
  - automatische Null-tenant-Backfills + rollback-safe self-healing.
- Admin-Endpunkte tenant-aware gemacht (lesen/schreiben/testen):
  - Knowledge ingest status
  - Member-memory scheduler status/settings
  - Integrations config + integration test status
  - Generic settings read/update
  - Plans/Billing bleiben als globale Systemkonfiguration (explizit global keys).
- Runtime tenant-aware erweitert:
  - SMTP/verification mail settings im Gateway jetzt mit `tenant_id` aufgelöst.
  - Member enrichment liest `checkin_enabled` tenant-spezifisch.
  - Member-memory LLM/cron settings tenant-spezifisch.
- Neue Tests:
  - `tests/test_settings_tenant_scope.py`
- Verifikation:
  - `python -m py_compile` auf geänderten Dateien: OK
  - `.venv/bin/pytest -q tests/test_settings_tenant_scope.py tests/test_security_hardening.py tests/test_auth_restore.py tests/test_persistence_tenant_scope.py` => `10 passed`.

## Ghost Mode / Admin Impersonation (System Admin)
- Backend-Auth erweitert für sicheren Impersonation-Flow:
  - Neue Token-Claims `imp` mit Actor-Metadaten (system_admin), Grund und Startzeit.
  - `AuthContext` trägt nun optional Impersonation-Kontext (`is_impersonating`, Actor-Felder).
  - Neue Endpoints:
    - `POST /auth/users/{user_id}/impersonate` (nur system_admin, mit Pflicht-Reason, kein self/system_admin target, TTL 45 Minuten)
    - `POST /auth/impersonation/stop` (Rückkehr zur ursprünglichen system_admin Session)
  - `/auth/me` liefert bei aktiver Impersonation ein `impersonation`-Objekt.
  - Audit-Events: `auth.impersonation.start` und `auth.impersonation.stop`.
- Frontend umgesetzt:
  - `/users`: Für system_admins neuer `Ghost Mode`-Button pro User-Zeile (ausgenommen system_admin/self), inkl. Reason-Modal.
  - Globaler Ghost-Banner in `NavShell` mit aktiver Zielidentität + `Ghost Mode beenden`.
  - Session-Sync verbessert via `ariia:session-updated` Event in `frontend/lib/auth.ts`.
  - Auth-Proxy setzt Session-Cookies jetzt auch bei Impersonation-Start/Stop Responses.
- Verifikation:
  - `python -m py_compile app/core/auth.py app/gateway/auth.py app/gateway/admin.py` OK.
  - Tests: `.venv/bin/pytest -q tests/test_auth_restore.py tests/test_security_hardening.py` => `7 passed`.
  - Neuer Flow-Test enthalten: `test_system_admin_can_impersonate_tenant_user_and_exit`.
